{{define "channel"}}
package signal

// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

type (
	{{ .ChannelType }} struct {
		buffer  {{ .Interface }}
		channel int
	}
)

// Append panics.
func (c {{ .ChannelType }}) Append(s {{ .Interface }}) {
	panic("appending signal to the single channel")
}

// AppendSample panics.
func (c {{ .ChannelType }}) AppendSample(s {{ .SampleType }}) {
	panic("appending sample to the single channel")
}

// BufferIndex returns sample index in the channel of signal buffer.
func (c {{ .ChannelType }}) BufferIndex(channel int, index int) int {
	return c.channel * index
}

// Channels always returns 1.
func (c {{ .ChannelType }}) Channels() int {
	return 1
}

// Cap returns capacity of the channel.
func (c {{ .ChannelType }}) Cap() int {
	return c.buffer.Capacity()
}

// Capacity returns capacity of the channel.
func (c {{ .ChannelType }}) Capacity() int {
	return c.buffer.Capacity()
}

// Len returns length of the channel.
func (c {{ .ChannelType }}) Len() int {
	return c.buffer.Length()
}

// Length returns length of the channel.
func (c {{ .ChannelType }}) Length() int {
	return c.buffer.Length()
}

// Channel panics.
func (c {{ .ChannelType }}) Channel(channel int) {{ .Interface }} {
	panic("slicing channel of the channel")
}

// Sample returns signal value for provided channel and index.
func (c {{ .ChannelType }}) Sample(index int) {{ .SampleType }} {
	return c.buffer.Sample(index * c.channel)
}

// SetSample sets sample value for provided index.
func (c {{ .ChannelType }}) SetSample(index int, s {{ .SampleType }}) {
	c.buffer.SetSample(c.buffer.BufferIndex(c.channel, index), s)
}

// Free panics.
func (c {{ .ChannelType }}) Free(*PoolAllocator) {
	panic("freeing single channel of the buffer")
}

// Slice slices buffer with respect to channels.
func (c {{ .ChannelType }}) Slice(start, end int) {{ .Interface }} {
	return {{ .ChannelType }}{
		buffer:  c.buffer.Slice(start, end),
		channel: c.channel,
	}
}

{{if ne .Interface "Floating"}}
func (c {{ .ChannelType }}) BitDepth() BitDepth {
	return c.buffer.BitDepth()
}
{{end}}
{{end}}

{{define "channel_tests"}}package signal_test

// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

import (
	"testing"

	"pipelined.dev/signal"
)

func Test{{ .Interface }}Channel(t *testing.T) {
	test{{ .Interface }} := func() func(*testing.T) {
		result := signal.Allocator{
			Channels: 3,
			Length:   3,
			Capacity: 3,
		}.{{ .Name }}({{if ne .Interface "Floating"}}signal.BitDepth32{{end}})
		channel := 1
		c := result.Channel(channel).Slice(0, 2)
		for i := 0; i < c.Len(); i++ {
			c.SetSample(i, {{ .SampleType }}(i+1))
		}
		return func(t *testing.T) {
			assertEqual(t, "channels", c.Channels(), 1)
			assertEqual(t, "length", c.Len(), c.Length())
			assertEqual(t, "capacity", c.Cap(), c.Capacity())
			for i := 0; i < c.Cap(); i++ {
				assertEqual(t, "index", c.Sample(i), result.Sample(c.BufferIndex(channel, i)))
			}
		}
	}
	testPanic := func() func(*testing.T) {
		result := signal.Allocator{
			Channels: 3,
			Length:   3,
			Capacity: 3,
		}.{{ .Name }}({{if ne .Interface "Floating"}}signal.BitDepth32{{end}})
		c := result.Channel(1)
		return func(t *testing.T) {
			assertPanic(t, func() {
				c.Append(nil)
			})
			assertPanic(t, func() {
				c.AppendSample(0)
			})
			assertPanic(t, func() {
				c.Channel(0)
			})
			assertPanic(t, func() {
				c.Free(nil)
			})
		}
	}

	t.Run("{{ .Interface }} channel", test{{ .Interface }}())
	t.Run("panic {{ .Interface }} channel", testPanic())
}
{{end}}